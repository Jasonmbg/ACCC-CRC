---
title: "ACCC-CRC RNASeq Analysis"
number-sections: true
include-after-body: "footer.html"
format: 
 html:
  code-fold: true
  code-summary: "Show the code"
author: Efstathios-Iason Vlachavas
date: last-modified
date-format: YYYY-MM-DD
toc: true
theme: "litera"
editor: visual
include-in-header:
   - text: |
       <style>
       figcaption {
         text-align: center;
       }
       </style>
warning: false
---

# ACCC-CRC RNASeq dataset analysis overview

### Reproduce the analysis of the rnaseq data from the main ACCC-CRC dataset for the manuscript.

Initially start by loading the necessary R packages, along with importing the clinical information.

```{r}

# For the appropriate order of jumping into the analysis, please check initially and refer to the Clinical_Process_MSI.R file, to see the respective clinical files and MSI inferred information;

# load the necessary packages and initially read the necessary clinical data:

library(tidyverse)
library(data.table)
library(EnsDb.Hsapiens.v75)
library(biomaRt)
library(limma)
library(edgeR)
library(progeny)
library(dorothea)
library(decoupleR)
library(xml2)
library(downlit)
library(here)
library(ComplexHeatmap)
library(circlize)
library(hrbrthemes)
library(ggrepel)
library(DT)

dr_here()

merged.final.accc.clin.pheno.dat <- read_tsv(here("Data", "CRC.ACCC.Clinical.Total.Merged.MSI.Mut.Info.RNASeq.tsv"))

eda_pheno_accc <- merged.final.accc.clin.pheno.dat |>
dplyr::select(Sample_Name, Condition, MSI_status, sex, tumor_location)

datatable(eda_pheno_accc, filter = "top")

```

### Then load-preprocess the rnaseq data

```{r}

# read first the raw counts expression object:

load("Data/ACCC_CRC_RNASeq_Raw_Counts_DT.rda")

# continue with annotation process 

edb <- EnsDb.Hsapiens.v75

ensembl.genes <- as.character(rownames(dt.counts))

gene.ids <- ensembldb::select(edb, keys = ensembl.genes, keytype = "GENEID",
columns = c("GENENAME", "GENEBIOTYPE")) # ensembldb::select; check with updated versions if the bug with mapIDs has been corrected-also regarding the duplicates, by using GENEBIOTYPE instead of TXBIOTYPE there should not be duplicates anymore

final.annot <- gene.ids |> as_tibble() |>
dplyr::filter(!is.na(GENENAME)) |> 
dplyr::filter(GENEBIOTYPE == "protein_coding") |>
dplyr::distinct(GENENAME,.keep_all=TRUE)

sel.ids <- as.character(final.annot$GENEID)

dt.counts.sel <- dt.counts[sel.ids,]

# then assign the relative rownames
merged.final.accc.clin.pheno.dat <- merged.final.accc.clin.pheno.dat |> mutate(MSI_status_reform=ifelse(MSI_status=="1","MSI","MSS")) |>
column_to_rownames("Sample_Name")

mat.counts <- as.matrix(dt.counts.sel)

identical(rownames(merged.final.accc.clin.pheno.dat), colnames(mat.counts)) 

# redundant but can run for sanity check regarding downstream approaches;
merged.final.accc.clin.pheno.dat$MSI_status_reform <- as.factor(merged.final.accc.clin.pheno.dat$MSI_status_reform)

y <- DGEList(counts=mat.counts, samples = merged.final.accc.clin.pheno.dat)

y$genes <- data.frame(ENSEMBL=rownames(y), SYMBOL=final.annot$GENENAME)

cond.MSI <- y$samples$MSI_status_reform

## The function *filterByExpr* keeps genes that have count-per-million (CPM) above k in n samples, where k is determined by min.count and by the sample library sizes and n is determined by the design matrix.

## n is essentially the smallest group sample size or, more generally, the minimum inverse leverage of any fitted value; In parallel, each retained gene is required to have at least min.total.count reads across all the samples.

## group argument: vector or factor giving group membership. 

keep.exprs <- filterByExpr(y, group=cond.MSI)

y.filt <- y[keep.exprs,, keep.lib.sizes=FALSE]

final.exp.gene.vector <- as.character(y.filt$genes$SYMBOL)
exp.dt.accc.crc.rnaseq <- final.exp.gene.vector |> as_tibble() |> dplyr::rename(ExpressedGenes.ACCC.CRC.RNAseq=value)

# write_tsv(exp.dt.accc.crc.rnaseq,"Exp.DT.ACCC.CRC.RNAseq.ReClassified.MSI.tsv")

dge <- calcNormFactors(y.filt, method = "TMM")

```

## EDA & DE analysis

```{r, fig.width=11}

par(mfrow=c(1,2))
lcpm <- cpm(y, log=TRUE)

boxplot(lcpm, las=2, col="red", main="", names = rep("", ncol(lcpm)))
title(main="A: Unnormalised data",ylab="Log-cpm") 

lcpm <- cpm(dge, log=TRUE)
boxplot(lcpm, las=2, col="blue", main="", names = rep("", ncol(lcpm)))
title(main="B: Normalised data",ylab="Log-cpm")

par(mfrow=c(1,1))

######## PCA plot with multiple labels ###############
mat <- lcpm
pca <- prcomp(t(mat), scale=TRUE) # check about scaling
eig <- (pca$sdev)^2
variance <- eig*100/sum(eig)
dat <-as.data.frame(dge$samples)

ggplot(dat, aes(pca$x[,1], pca$x[,2], color=factor(MSI_status), shape=Condition)) +
geom_point(size=3) + geom_text(aes(label=Condition)) + xlab(paste0("PC1: 
",round(variance[1],2),"% variance")) + ylab(paste0("PC2: 
",round(variance[2],2),"% variance"))

MSI_status_cond <- as.factor(dge$samples$MSI_status_reform)

design <- model.matrix(~0 + MSI_status_cond)
colnames(design) <- levels(MSI_status_cond)

v1 <- voomWithQualityWeights(dge, design, plot = T)

###############################################################################################
# optional: save here the normalized/transformed counts into a object to be used for downstream visualization purposes

norm.voom.mat <- v1$E
# save to use downstream-the same as above when created 
rownames(norm.voom.mat) <- as.character(v1$genes$SYMBOL) 
accc.crc.norm.dat <- norm.voom.mat |> as.data.frame() |> rownames_to_column()
# write_tsv(accc.crc.norm.dat, file="ACCC.CRC.Norm.VoomQualWeights.CPM.REclassified.MSI.tsv")

##############################################################################################

voom.fit <- lmFit(v1, design)

contrast.matrix <- makeContrasts(comp1= MSI - MSS,
                                         levels=design)   

fit2 <- contrasts.fit(voom.fit, contrast.matrix)
fit3 <- eBayes(fit2, trend = TRUE, robust = TRUE)
plotSA(fit3, main="Final model: Mean-variance trend")

comp1_stat <- limma::topTable(fit3, coef=1, number=nrow(fit3), adjust.method="fdr", sort.by="none") |> rownames_to_column() |> dplyr::select(SYMBOL,t) %>% column_to_rownames("SYMBOL") |> dplyr::rename(MSI_vs_MSS_stat=t)

```

#### Pathway activity analysis-initially utilize the MSI status information, to perform a similar analysis as in the two public CRC datasets {part of the output for Figure 3 creation}

```{r}

total_stat_dat <- comp1_stat |> as.matrix()

PathwayActivity_zscore <- progeny(total_stat_dat, 
    scale=TRUE, organism="Human", top = 100, perm = 10000, z_scores = TRUE) |>
    t()
colnames(PathwayActivity_zscore) <- c("NES_MSI_vs_MSS")

PathwayActivity_zscore_df <- as.data.frame(PathwayActivity_zscore) |> 
    rownames_to_column(var = "Pathway") |>
    dplyr::arrange(NES_MSI_vs_MSS) |>
    dplyr::mutate(Pathway = factor(Pathway))

ggplot(PathwayActivity_zscore_df,aes(x = reorder(Pathway, NES_MSI_vs_MSS), 
    y = NES_MSI_vs_MSS)) + 
    geom_bar(aes(fill = NES_MSI_vs_MSS), stat = "identity") +
    scale_fill_gradient2(low = "darkblue", high = "indianred", 
        mid = "whitesmoke", midpoint = 0) + 
    theme_minimal() +
    theme(axis.title = element_text(face = "bold", size = 12),
        axis.text.x = 
            element_text(angle = 45, hjust = 1, size =10, face= "bold"),
        axis.text.y = element_text(size =10, face= "bold"),
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank()) +
    xlab("Pathways")

Path.act.dat <- as.data.frame(PathwayActivity_zscore)
Path.act.dat <- Path.act.dat |> rownames_to_column() |>
dplyr::rename(PROGENY_pathways=rowname)

# write_tsv(Path.act.dat, file="PathwayActivity_zscore.ACCC.CRC.ReClassified.MSI.Pathways.tsv")

```

#### Also small example to further exploit specific pathway-responsive genes dependencies:
here we exploit further the TGFb immune pathway

```{r}
#| fig-align: center
#| fig-width: 10
#| fig-height: 8
#| fig.cap: "The TGFb pathway seems to be de-activated in MSI when compared to MSS, since the majority of top-20 most responsive target genes with positive weights have negative t-values (4th quadrant)."
#| message: false

prog_matrix <- getModel("Human", top=100) |> 
as.data.frame()  |>
tibble::rownames_to_column("GeneID")

pd_TGFb <- prog_matrix |> arrange(desc(abs(TGFb))) |> slice_head(n=100)

comp_1_df <- comp1_stat |> rownames_to_column()

sel.genes.TGFb <- inner_join(pd_TGFb, comp_1_df, by = c("GeneID"="rowname"))

sel.genes.TGFb <- sel.genes.TGFb |> dplyr::select(GeneID,TGFb,MSI_vs_MSS_stat)

df_TGFb_out <- sel.genes.TGFb |> mutate(Gene_impact=TGFb*MSI_vs_MSS_stat) |> arrange(desc(abs(Gene_impact))) |> slice_head(n=20)

df_TGFb <- sel.genes.TGFb |> mutate(color = "3") |> mutate(Gene_impact=TGFb*MSI_vs_MSS_stat) |> arrange(desc(abs(Gene_impact))) |> slice_head(n=20) |> dplyr::rename(TGFb_weight=TGFb) |>
  mutate(color = if_else(TGFb_weight > 0 & MSI_vs_MSS_stat > 0, '1', color)) |>
  mutate(color = if_else(TGFb_weight > 0 & MSI_vs_MSS_stat < 0, '2', color)) |>
  mutate(color = if_else(TGFb_weight < 0 & MSI_vs_MSS_stat > 0, '2', color)) |>
  mutate(color = if_else(TGFb_weight < 0 & MSI_vs_MSS_stat < 0, '1', color))

  ggplot(df_TGFb, aes(x = TGFb_weight, y = MSI_vs_MSS_stat, color = color)) + 
  geom_point() +
  scale_colour_manual(values = c("red","royalblue3","grey")) +
  geom_label_repel(aes(label = GeneID)) + 
  theme_minimal() +
  theme(legend.position = "none") +
  geom_vline(xintercept = 0, linetype = 'dotted') +
  geom_hline(yintercept = 0, linetype = 'dotted') +
  ggtitle("TGFb") +
  theme_ipsum()

```

#### Similarly for the TF-activity inference analysis

```{r}

plot_top_features <- function(data, n_top) {

  colnames(data) <- "value"

  arranged <- data %>%
    as.data.frame() %>%
    tibble::rownames_to_column(var = "id") %>%
    arrange(desc(value))

  top_up <- slice_head(arranged, n = n_top)
  top_down <- slice_tail(arranged, n = n_top)

  p <- bind_rows(list(up = top_up, down = top_down), .id = "status") %>%
    mutate(id = fct_inorder(id)) %>%
    ggplot(aes(x = value, y = id, fill = status)) +
    geom_bar(stat = "identity") +
    scale_fill_manual(values = c("up" = "red", "down" = "blue")) +
    theme_bw()

  return(p)

}

dorothea_df <- as.data.frame(dorothea_hs[dorothea_hs$confidence %in% c("A","B","C"),c(3,1,4)])
dorothea_df$likelihood <- 1

dorothea_df <- intersect_regulons(as.matrix(comp1_stat), dorothea_df, .source = tf, .target = target, minsize=20)

TF_activities_MSI_vs_MSS <- as.data.frame(run_wmean(mat = as.matrix(comp1_stat), network = dorothea_df, .source = "tf", .target = "target", times = 1000))

# for extra save with all information:
dat.TF_activities_MSI_vs_MSS <- TF_activities_MSI_vs_MSS |> 
dplyr::filter(statistic=="norm_wmean") |> dplyr::select(statistic,source,score,p_value)

# write_tsv(dat.TF_activities_MSI_vs_MSS, file="ACCC.CRC.TFact.MSI_vs_MSS.RES.TotalTable.ReClassified.tsv")

TF_activities_MSI_vs_MSS <- TF_activities_MSI_vs_MSS[TF_activities_MSI_vs_MSS$statistic == "norm_wmean",c(2,4)] |> as_tibble() |> column_to_rownames(var="source")

plot_top_features(TF_activities_MSI_vs_MSS, n_top = 10) +
  ggtitle('TF top10 activities MSI_vs_MSS')

```

#### Also continue with firstly creating the **Figure 4.A** part with pathway/TF activities per patient

```{r,warning=FALSE, out.width="300px"}

library(tidyverse)
library(ComplexHeatmap)
library(circlize)
library(InteractiveComplexHeatmap)

out.CMS.ACCC <- read_tsv(here("Data","Out_RES_DT_CMScaller_ACCC_28samples.tsv"))
out.CMS.ACCC.sel <- out.CMS.ACCC %>% dplyr::select(ACCC_Sample_ID, prediction)

setwd("C:/Users/e376s/Desktop/OnkoKB.Match.Scored.ACCC/ACCC_CRC_Patient_Level/Clustering/FINAL")

cluster_info <- read_tsv(here("Data","HCPC_FactoMineR_RES_ACCC_CRC.tsv"))

cluster_info_merge <- inner_join(cluster_info, out.CMS.ACCC.sel, by=c("Sample_ID"="ACCC_Sample_ID"))

cluster_info_ord <- cluster_info_merge[order(cluster_info_merge$clust, cluster_info_merge$MSI_status, cluster_info_merge$Condition),] # updated grouping based also on subsequently the MSI status + mutational groups

pdat_ord <- cluster_info_ord |> dplyr::select(c("Sample_ID","MSI_status","Condition","sex", "histological_subtype","tumor_location","clust","prediction")) %>% column_to_rownames("Sample_ID")

# load the patient-inferred pathway/TF activities:

Path_act <- read_tsv(here("Data",
"PathwayActivity_zscore_ACCC_CRC_Scaled_PatientLevel_PROGENY.tsv"))
Path_act_2 <- Path_act |> column_to_rownames(var="PROGENY_pathways")

TF_act <- read_tsv(here("Data","TFactivity_zscore_ACCC_CRC_Scaled_PatientLevel_DOROTHEA.tsv"))
TF_act_2 <- TF_act |> dplyr::select(TFs_Dorothea,condition,score) |> pivot_wider(names_from="condition",values_from="score") |> column_to_rownames(var="TFs_Dorothea")

# reorder columns for each numeric dataset
pathway_scaled_order = Path_act_2[, rownames(pdat_ord)]
TF_scaled_order= TF_act_2[,rownames(pdat_ord)]

col_fun_1 = colorRamp2(c(-5, 0, 5), c("#377EB8", "white", "#E41A1C"))

ha_add = HeatmapAnnotation(
    MSI_status = ifelse(pdat_ord[[1]] == 1, "MSI","MSS"),
    Mutation_group = pdat_ord[[2]],
    Sex = ifelse(pdat_ord[[3]] == "F", "Female","Male"),
    Histo_Subtype = pdat_ord[[4]],
    Tumor_Location = pdat_ord[[5]],
    Cluster_ID = pdat_ord[[6]],
    CMS_subtype = pdat_ord[[7]],
    border = TRUE,
    col = list(Mutation_group = structure(names = c("BRAF_mut", "KRAS_mut", 
    "GNAS_mut", "NRAS_mut", "RAS_RAF_GNAS_wt", "RAS_RAF_GNAS_mut"), 
    c("yellow", "red", "black", "green", "orange", "cyan")),
    MSI_status = structure(names = c("MSI","MSS"), c("red","black")),
    Sex = structure(names = c("Female","Male"), c("red","black")),
    Histo_Subtype = structure(names = c("adenoCa_int_diff","adenoCa_low_diff","adenoCa_NOS",
    "desmin_adenoCa","LVI_adenoCa_int diff","src_mucinous_adenoCa"), 
    c("yellow", "red", "blue", "black", "green", "orange")),
    Tumor_Location = structure(names = c("left_sided","right_sided"), c("red","black")),
    Cluster_ID = structure(names = c("1","2","3"),c("black","red","blue")),
    CMS_subtype = structure(names = c("CMS1","CMS2","CMS3","CMS4"),            c("orange","blue","purple","darkgreen")))) 

ht1_final_2 = Heatmap(pathway_scaled_order, name="Pathway_activity",cluster_columns = FALSE, top_annotation = ha_add,show_column_names = TRUE,col=col_fun_1,row_names_gp = gpar(fontsize = 9),column_names_gp = gpar(fontsize = 8, fontface = "bold"), row_title = "Pathways",
show_row_dend = FALSE,
cell_fun = function(j, i, x, y, w, h, fill) {
    if(pathway_scaled_order[i, j] >= 2) {
        grid.text("*", x, y)
    } else if(pathway_scaled_order[i, j] <= -2) {
        grid.text("*", x, y)
    }
})

ht2_final_2 = Heatmap(TF_scaled_order, cluster_columns = FALSE, name= "TF_activity",
show_column_names = TRUE, col=col_fun_1,row_names_gp = gpar(fontsize = 9),row_title="TFs", show_row_dend = FALSE, column_names_gp = gpar(fontsize = 8, fontface = "bold"),
cell_fun = function(j, i, x, y, w, h, fill) {
    if(TF_scaled_order[i, j] >= 2) {
        grid.text("*", x, y)
    } else if(TF_scaled_order[i, j] <= -2) {
        grid.text("*", x, y)
    }
})

ht_list = ht1_final_2 %v% ht2_final_2

draw(ht_list)

```

<button type="button" class="btn btn-primary" data-bs-toggle="modal" data-bs-target="#exampleModal">

See in Full Screen

</button>

::: {#exampleModal .modal .fade tabindex="-1"}
::: {.modal-dialog .modal-dialog-centered .p-8 style="max-width: 90%"}
::: modal-content
```{r, echo=FALSE, warning=FALSE, out.width="100%"}
ht_list
```
:::
:::
:::

#### Then conceptualize the **Figure 4.B** part for the merged visualization with the ssGSEA/immune deconvolution estimates

```{r} 
#| fig-align: center
#| fig-width: 12
#| fig-height: 10
#| fig.cap: "Heatmap visualization of the normalized enrichment scores of selected hallmarks from MsigDb per patient using ssGSEA."
#| message: false

library(ComplexHeatmap)
library(circlize)
library(tidyverse)

ssGSEA.scores <- read_tsv(here("Data","ACCC_CRC_ssGSEA_NES_scores.txt"))

ssgsea.names <- as.character(ssGSEA.scores$id)
ssgsea.names.filt <- str_remove(ssgsea.names, pattern = "HALLMARK_")

scored.dat <- ssGSEA.scores |> column_to_rownames("id")
rownames(scored.dat) <- ssgsea.names.filt

# use the same phenotypic information as from above code chunk

exists("pdat_ord")

# continue with the visualization heatmap

cluster.ord <- as.character(rownames(pdat_ord))

sel.hallmark.terms <- c("ANGIOGENESIS","TNFA_SIGNALING_VIA_NFKB",
               "NOTCH_SIGNALING","EPITHELIAL_MESENCHYMAL_TRANSITION","GLYCOLYSIS",
               "DNA_REPAIR","G2M_CHECKPOINT",
               "PI3K_AKT_MTOR_SIGNALING","INFLAMMATORY_RESPONSE",
               "FATTY_ACID_METABOLISM","MYC_TARGETS_V1","MYC_TARGETS_V2",
               "E2F_TARGETS","WNT_BETA_CATENIN_SIGNALING",
               "INTERFERON_GAMMA_RESPONSE","UNFOLDED_PROTEIN_RESPONSE",
               "CHOLESTEROL_HOMEOSTASIS") # selected representative hallmarks

gsea.score.sel <- scored.dat[sel.hallmark.terms,cluster.ord]

NES_ssGEA <- as.matrix(t(scale(t(gsea.score.sel))))
rownames(NES_ssGEA)[4] <- "EMT" # FOR "EPITHELIAL_MESENCHYMAL_TRANSITION"

# create an additional heatmap with the ESTIMATE scores

ESTIMATE.dat <- read_tsv(here("Data",
"Immunedeconv.RES.ESTIMATE.ACCC.CRC.MSI.REClassified.UnLogTPM.tsv"))

ESTIMATE.dat.filt <- ESTIMATE.dat |> dplyr::filter(ESTIMATE_Scores%in%c("StromalScore","ImmuneScore")) |> column_to_rownames("ESTIMATE_Scores") |> as.matrix()

ESTIMATE.mat <- ESTIMATE.dat.filt[,rownames(pdat_ord)]

ESTIMATE_scaled <- as.matrix(t(scale(t(ESTIMATE.mat))))

# also include CIBERSORTx scaled cell fractions

cbx.dat <- read_tsv(here("Data","CIBERSORTx_Job6_Results_ABSMode.txt"))

# only to fetch the absolute score
cbx.mat2 <- cbx.dat |> dplyr::select(Mixture,`Absolute score (sig.score)`) |> pivot_longer(cols=-Mixture) |>
pivot_wider(names_from = Mixture, values_from = value) %>% column_to_rownames("name") |> as.matrix()

CIBERSORT_ord <- cbx.mat2[,cluster.ord]

CIBERSORT_ord_mat <- CIBERSORT_ord |> enframe() |> pivot_wider(names_from = name, values_from = value) |> as.matrix()

rownames(CIBERSORT_ord_mat) <- "CIBERSORTx_ABS_score"

CIBERSORT_ord_mat_scaled <- as.matrix(t(scale(t(CIBERSORT_ord_mat)))) # final numeric input

# define the color palettes for the heatmaps
col_fun_1 = colorRamp2(c(-1, 0, 1), c("#377EB8", "white", "#E41A1C"))

ha_add = HeatmapAnnotation(
    MSI_status = ifelse(pdat_ord[[1]] == 1, "MSI","MSS"),
    Mutation_group = pdat_ord[[2]],
    Sex = ifelse(pdat_ord[[3]] == "F", "Female","Male"),
    Histo_Subtype = pdat_ord[[4]],
    Tumor_Location = pdat_ord[[5]],
    Cluster_ID = pdat_ord[[6]],
    CMS_subtype = pdat_ord[[7]],
    border = TRUE,
    col = list(Mutation_group = structure(names = c("BRAF_mut", "KRAS_mut", 
    "GNAS_mut", "NRAS_mut", "RAS_RAF_GNAS_wt", "RAS_RAF_GNAS_mut"), 
    c("yellow", "red", "black", "green", "orange", "cyan")),
    MSI_status = structure(names = c("MSI","MSS"), c("red","black")),
    Sex = structure(names = c("Female","Male"), c("red","black")),
    Histo_Subtype = structure(names = c("adenoCa_int_diff","adenoCa_low_diff","adenoCa_NOS",
    "desmin_adenoCa","LVI_adenoCa_int diff","src_mucinous_adenoCa"), 
    c("yellow", "red", "blue", "black", "green", "orange")),
    Tumor_Location = structure(names = c("left_sided","right_sided"), c("red","black")),
    Cluster_ID = structure(names = c("1","2","3"),c("black","red","blue")),
    CMS_subtype = structure(names = c("CMS1","CMS2","CMS3","CMS4"),            c("orange","blue","purple","darkgreen")))) 

ht1 = Heatmap(ESTIMATE_scaled, name="Immune_Deconv_ESTIMATE_Zscore",top_annotation = ha_add,
              row_title = "EST", column_names_gp = gpar(fontsize = 7),
              cluster_columns = FALSE, show_column_names = TRUE, col=col_fun_1, 
              row_names_gp = gpar(fontsize = 9),show_row_dend = FALSE)

# this for the absolute ABS score estimate from CIBERSORTX !!
ht2 = Heatmap(CIBERSORT_ord_mat_scaled, name="Immune_Deconv_CIBERSORTx_ABS_Zscore",
              row_title = "CBRx",cluster_columns = FALSE, show_column_names = TRUE,                         col=col_fun_1, row_names_gp = gpar(fontsize = 9),show_row_dend = FALSE)

ht3 = Heatmap(NES_ssGEA, name="NES_ssGSEA_Zscore",
              cluster_columns = FALSE, show_column_names = TRUE, 
              col=col_fun_1, row_names_gp = gpar(fontsize = 9),
row_title = "MsigDb_Sel_Hallmarks",show_row_dend = FALSE)

ht_list = ht1 %v% ht2 %v% ht3

draw(ht_list)

```
